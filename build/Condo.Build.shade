use namespace = 'System'
use namespace = 'System.Collections.Generic'
use namespace = 'System.Diagnostics'
use namespace = 'System.IO'
use namespace = 'System.Linq'

use namespace = 'Sake.Engine.Logging'

default Quiet = '${ false }'

macro name='ExecuteRuby' args='string'
    ruby ruby_args='${ args }'

@{
    // set the log instance on the helper class
    Build.Log = new QuietLog(this.Log, Quiet);

    // replace the current instance of the logger with the one that handles "quiet"
    this.Log = Build.Log;
}

functions @{
    public interface IQuietLog : ILog
    {
        bool Quiet { get; set; }

        bool Secure { get; set; }

        void Header(string value = null, string line = "-");
        void Info(object value, bool secure);
        void Warn(object value, bool secure);
        void Error(object value, bool secure);
        void Verbose(object value, bool secure);
        void Argument(string name, object value, bool secure = false);
    }

    public class QuietLog : IQuietLog
    {
        private ILog log;

        private const string ArgumentFormat = "- {0,-20}: {1}";

        public QuietLog(ILog log, bool quiet)
        {
            this.Quiet = quiet;
            this.log = log;
        }

        public void Header(string name, string line)
        {
            if (!string.IsNullOrEmpty(name))
            {
                this.Info(name.ToUpper());
            }

            this.Verbose(string.Empty.PadLeft(105, line[0]));
        }

        public void Info(object value)
        {
            var padded = (value ?? string.Empty).ToString().Trim();
            padded = padded.PadLeft(3 + padded.Length);

            this.log.Info(padded);
        }

        public void Info(object value, bool secure)
        {
            this.Info(this.Secure && secure ? "<secured>" : value);
        }

        public void Warn(object value)
        {
            var padded = (value ?? string.Empty).ToString().Trim();
            padded = padded.PadLeft(3 + padded.Length);

            this.log.Warn(padded);
        }

        public void Warn(object value, bool secure)
        {
            this.Warn(this.Secure && secure ? "<secured>" : value);
        }

        public void Error(object value)
        {
            var padded = (value ?? string.Empty).ToString().Trim();
            padded = padded.PadLeft(3 + padded.Length);

            this.log.Error(padded);
        }

        public void Error(object value, bool secure)
        {
            this.Error(this.Secure && secure ? "<secured>" : value);
        }

        public void Verbose(object value)
        {
            if (!this.Quiet)
            {
                this.log.Verbose(value);
            }
        }

        public void Verbose(object value, bool secure)
        {
            this.Verbose(this.Secure && secure ? "<secured>" : value);
        }

        public void Argument(string name, object value, bool secure = false)
        {
            if (string.IsNullOrEmpty(name) || value == null || string.IsNullOrEmpty(value.ToString()))
            {
                return;
            }

            if (this.Secure && secure)
            {
                value = "<secured>";
            }

            this.Verbose(string.Format(ArgumentFormat, name, value), false);
        }

        public bool Quiet { get; set; }
        public bool Secure { get; set; }
    }

    public class InstallPath
    {
        public string Path { get; set; }
        public bool Global { get; set; }
    }

    /// <summary>
    /// Represents a helper class used to store and retrieve build environment configuration.
    /// </summary>
    public static class Build
    {
        private static readonly string[] DefaultExcludes = new[] { "node_modules", "bower_components", "wwwroot" };

        private static readonly IList<Process> Processes = new List<Process>();

        private static readonly IDictionary<string, InstallPath> InstallPaths = new Dictionary<string, InstallPath>();

        /// <summary>
        /// Gets a value indicating whether or not the build environment is running on a Unix-based
        /// host.
        /// </summary>
        public static bool Unix
        {
            get
            {
                // get the platform identifier as an integer
                // tricky: this is necessary as the 1.x mono runtime used a value of 128 for
                // unix environments, which doesn't exist on the PlatformID enumeration in
                // .NET or in 2.x mono runtime
                var id = (int)Environment.OSVersion.Platform;

                // tricky:
                //  - 4 = Mac OS X (DNX / Mono 2.x)
                //  - 6 = Unix (DNX / Mono 2.x)
                //  - 128 = Unix (Mono 1.x)
                return id == 4 || id == 6 || id == 128;
            }
        }

        /// <summary>
        /// Gets a value indicating whether or not the build environment is running on an OS X-based
        /// host.
        /// </summary>
        public static bool OSX
        {
            get
            {
                // get the platform id
                var id = (int)Environment.OSVersion.Platform;

                // determine if the platform is OS X
                return id == 4;
            }
        }

        public static bool Windows
        {
            get
            {
                return !Build.Unix;
            }
        }

        public static bool CI
        {
            get
            {
                return !string.IsNullOrEmpty(Build.Get("CI"));
            }
        }

        public static bool TFS
        {
            get
            {
                return !string.IsNullOrEmpty(Build.Get("SYSTEM_DEFINITIONID")) && !string.IsNullOrEmpty(Build.Get("TF_BUILD"));
            }
        }

        public static bool TFSAgent
        {
            get
            {
                return TFS && !string.IsNullOrEmpty(Build.Get("AGENT_ID"));
            }
        }

        public static bool Travis
        {
            get
            {
                return !string.IsNullOrEmpty(Build.Get("TRAVIS"));
            }
        }

        public static bool AppVeyor
        {
            get
            {
                return !string.IsNullOrEmpty(Build.Get("APPVEYOR"));
            }
        }

        public static bool PullRequest { get; set; }

        /// <summary>
        /// Gets a value indicating whether or not the build environment is executing within the
        /// mono runtime.
        /// </summary>
        public static bool Mono
        {
            get
            {
                return Type.GetType("Mono.Runtime") != null;
            }
        }

        /// <summary>
        /// Gets the path for the specified name.
        /// </summary>
        public static InstallPath GetPath(string name)
        {
            InstallPath path;

            if (InstallPaths.TryGetValue(name, out path))
            {
                return path;
            }

            return null;
        }

        public static InstallPath GetOrSetPath(string name, string path, bool global)
        {
            InstallPath temp;

            if (InstallPaths.TryGetValue(name, out temp))
            {
                return temp;
            }

            temp = new InstallPath { Path = path, Global = global };

            InstallPaths.Add(name, temp);

            return temp;
        }

        public static InstallPath SetPath(string name, string path, bool global)
        {
            var temp = new InstallPath { Path = path, Global = global };

            InstallPaths[name] = temp;

            return temp;
        }

        /// <summary>
        /// Gets the value of the environment variable with the specified <paramref name="key"/>.
        /// </summary>
        /// <param name="key">
        /// The name of the environment variable for which to retrieve a value.
        /// </param>
        /// <param name="default">
        /// The default value if no value is present.
        /// </param>
        /// <returns>
        /// The value of the environment variable with the specified <paramref name="key"/>; otherwise
        /// <see langword="string.Empty"/>.
        /// </returns>
        public static string Get(string key, string @default = "")
        {
            // get the environment variable
            return Environment.GetEnvironmentVariable(key) ?? @default;
        }

        /// <summary>
        /// Sets the environment variable with the specified <paramref name="key"/> to the specified
        /// <paramref name="value"/>.
        /// </summary>
        /// <param name="key">
        /// The name of the environment variable to set to the specified <paramref name="value"/>.
        /// </param>
        /// <param name="value">
        /// The value to which to set the environment variable with the specified <paramref name="key"/>.
        /// </param>
        /// <param name="replace">
        /// A value indicating whether or not to append the value to any existing value.
        /// </param>
        public static void Set(string key, string value, bool append = false)
        {
            // determine if the value is being appended
            if (append)
            {
                // get the current value and append the new value; finally trim any whitespace
                value = string.Concat(Build.Get(key), " ", value).Trim();
            }

            // set the environment variable
            Environment.SetEnvironmentVariable(key, value);
        }

        /// <summary>
        /// Executes the specified <paramref name="command"/> with the specified <paramref name="arguments"/> and determines
        /// whether or not it succeeds at the command line.
        /// </summary>
        /// <param name="command">
        /// The command to execute at the command line.
        /// </param>
        /// <param name="args">
        /// The arguments to execute at the command line.
        /// </param>
        /// <param name="workingPath">
        /// The path in which to execute the specified <paramref name="command"/>.
        /// </param>
        /// <param name="quiet">
        /// A value indicating whether or not to execute the specified <paramref name="command"/> without emitting output from the
        /// process.
        /// </param>
        /// <param name="wait">
        /// A value indicating whether or not to wait for the process to exit.
        /// </param>
        /// <param name="redirect">
        /// A value indicating whether or not to redirect output.
        /// </param>
        /// <param name="attempts">
        /// The total number of attempts to try for a successful result.
        /// </param>
        public static bool TryExecute
            (
                string command,
                string args = "",
                string workingPath = "",
                bool quiet = true,
                bool wait = true,
                bool redirect = true,
                int attempts = 1
            )
        {
            string result;
            int exitCode;

            return Build.TryExecute(command, out exitCode, out result, args, workingPath, quiet, wait, redirect, attempts);
        }

        /// <summary>
        /// Attempts to execute the specified <paramref name="command"/> with the optionally specified <paramref name="args"/>.
        /// </summary>
        /// <param name="command">
        /// The command that should be executed at the CLI.
        /// </param>
        /// <param name="exitCode">
        /// When the method returns, the exit code of the process that was used to execute the specified <paramref name="command"/>.
        /// </param>
        /// <param name="args">
        /// Additional arguments to pass to the specified <paramref name="command"/>.
        /// </param>
        /// <param name="workingPath">
        /// The working path in which the specified <paramref name="command"/> should be executed.
        /// </param>
        /// <param name="quiet">
        /// A value indicating whether or not to execute the specified <paramref name="command"/> without emitting output from the
        /// process.
        /// </param>
        /// <param name="wait">
        /// A value indicating whether or not to wait for the process to exit.
        /// </param>
        /// <param name="redirect">
        /// A value indicating whether or not to redirect output.
        /// </param>
        /// <param name="attempts">
        /// The total number of attempts to try for a successful result.
        /// </param>
        public static bool TryExecute
            (
                string command,
                out int exitCode,
                string args = "",
                string workingPath = "",
                bool quiet = true,
                bool wait = true,
                bool redirect = true,
                int attempts = 1
            )
        {
            string result;

            return Build.TryExecute(command, out exitCode, out result, args, workingPath, quiet, wait, redirect, attempts);
        }

        /// <summary>
        /// Executes the specified <paramref name="command"/> with the specified <paramref name="arguments"/> and determines
        /// whether or not it succeeds at the command line.
        /// </summary>
        /// <param name="command">
        /// The command to execute at the command line.
        /// </param>
        /// <param name="result">
        /// When the method returns, will contain the output from standard output if the process was successful or standard error if the process
        /// was not successful.
        /// </param>
        /// <param name="args">
        /// The arguments to execute at the command line.
        /// </param>
        /// <param name="workingPath">
        /// The path in which to execute the specified <paramref name="command"/>.
        /// </param>
        /// <param name="quiet">
        /// A value indicating whether or not to execute the specified <paramref name="command"/> without emitting output from the
        /// process.
        /// </param>
        /// <param name="wait">
        /// A value indicating whether or not to wait for the process to exit.
        /// </param>
        /// <param name="redirect">
        /// A value indicating whether or not to redirect output.
        /// </param>
        /// <param name="attempts">
        /// The total number of attempts to try for a successful result.
        /// </param>
        public static bool TryExecute
            (
                string command,
                out string result,
                string args = "",
                string workingPath = "",
                bool quiet = true,
                bool wait = true,
                bool redirect = true,
                int attempts = 1
            )
        {
            int exitCode;

            return Build.TryExecute(command, out exitCode, out result, args, workingPath, quiet, wait, redirect, attempts);
        }

        /// <summary>
        /// Attempts to execute the specified <paramref name="command"/> with the optionally specified <paramref name="args"/>.
        /// </summary>
        /// <param name="command">
        /// The command that should be executed at the CLI.
        /// </param>
        /// <param name="exitCode">
        /// When the method returns, the exit code of the process that was used to execute the specified <paramref name="command"/>.
        /// </param>
        /// <param name="result">
        /// When the method returns, will contain the output from standard output if the process was successful or standard error if the process
        /// was not successful.
        /// </param>
        /// <param name="args">
        /// Additional arguments to pass to the specified <paramref name="command"/>.
        /// </param>
        /// <param name="workingPath">
        /// The working path in which the specified <paramref name="command"/> should be executed.
        /// </param>
        /// <param name="quiet">
        /// A value indicating whether or not to execute the specified <paramref name="command"/> without emitting output from the
        /// process.
        /// </param>
        /// <param name="wait">
        /// A value indicating whether or not to wait for the process to exit.
        /// </param>
        /// <param name="redirect">
        /// A value indicating whether or not to redirect output.
        /// </param>
        /// <param name="attempts">
        /// The total number of attempts to try for a successful result.
        /// </param>
        public static bool TryExecute
            (
                string command,
                out int exitCode,
                out string result,
                string args = "",
                string workingPath = "",
                bool quiet = true,
                bool wait = true,
                bool redirect = true,
                int attempts = 1
            )
        {
            result = null;

            try
            {
                // attempt to execute the command
                exitCode = Build.Execute(command, out result, args, workingPath, quiet, wait, redirect, attempts);
            }
            catch (Exception netEx)
            {
                // set the exit code to -1 as a default error
                exitCode = -1;

                // set the result to the message
                result = netEx.Message;
            }

            // return true if the exit code is 0
            return exitCode == 0;
        }

        /// <summary>
        /// Executes the specified <paramref name="command"/> with the specified <paramref name="arguments"/> and determines
        /// whether or not it succeeds at the command line.
        /// </summary>
        /// <param name="command">
        /// The command to execute at the command line.
        /// </param>
        /// <param name="args">
        /// The arguments to execute at the command line.
        /// </param>
        /// <param name="workingPath">
        /// The path in which to execute the specified <paramref name="command"/>.
        /// </param>
        /// <param name="quiet">
        /// A value indicating whether or not to execute the specified <paramref name="command"/> without emitting output from the
        /// process.
        /// </param>
        /// <param name="wait">
        /// A value indicating whether or not to wait for the process to exit.
        /// </param>
        /// <param name="redirect">
        /// A value indicating whether or not to redirect output.
        /// </param>
        /// <param name="attempts">
        /// The total number of attempts to try for a successful result.
        /// </param>
        public static int Execute
            (
                string command,
                string args = "",
                string workingPath = "",
                bool quiet = true,
                bool wait = true,
                bool redirect = true,
                int attempts = 1
            )
        {
            string result;

            return Build.Execute(command, out result, args, workingPath, quiet, wait, redirect, attempts);
        }

        /// <summary>
        /// Executes the specified <paramref name="command"/> with the specified <paramref name="arguments"/> and determines
        /// whether or not it succeeds at the command line.
        /// </summary>
        /// <param name="command">
        /// The command to execute at the command line.
        /// </param>
        /// <param name="result">
        /// When the method returns, will contain the output from standard output if the process was successful or standard error if the process
        /// was not successful.
        /// </param>
        /// <param name="args">
        /// The arguments to execute at the command line.
        /// </param>
        /// <param name="workingPath">
        /// The path in which to execute the specified <paramref name="command"/>.
        /// </param>
        /// <param name="quiet">
        /// A value indicating whether or not to execute the specified <paramref name="command"/> without emitting output from the
        /// process.
        /// </param>
        /// <param name="wait">
        /// A value indicating whether or not to wait for the process to exit.
        /// </param>
        /// <param name="redirect">
        /// A value indicating whether or not to redirect output.
        /// </param>
        /// <param name="attempts">
        /// The total number of attempts to try for a successful result.
        /// </param>
        public static int Execute
            (
                string command,
                out string result,
                string args = "",
                string workingPath = "",
                bool quiet = true,
                bool wait = true,
                bool redirect = true,
                int attempts = 1
            )
        {
            result = null;

            // determine if the working path is specified
            if (string.IsNullOrEmpty(workingPath))
            {
                // set the working path to the current directory
                workingPath = Directory.GetCurrentDirectory();
            }

            if (command.Contains(" "))
            {
                command = "\"" + command + "\"";
            }

            // determine process start information based on whether or not the CLI is executing on unix/linux or windows
            var info = Build.Unix
                ? new ProcessStartInfo { FileName = command, Arguments = args }
                : new ProcessStartInfo { FileName = "cmd", Arguments = " /S /C \"" + command + " " + args + "\"" };

            info.WorkingDirectory = workingPath;
            info.UseShellExecute = false;

            if (redirect)
            {
                info.RedirectStandardOutput = true;
                info.RedirectStandardError = true;
            }

            var retries = attempts;
            var exitCode = -1;

            while (retries-- > 0)
            {
                // create the process
                var process = new Process();
                process.StartInfo = info;
                process.EnableRaisingEvents = true;

                var standard = string.Empty;
                var error = string.Empty;

                process.OutputDataReceived += (sender, eventArgs) => {
                    standard += eventArgs.Data + Environment.NewLine;

                    if (!quiet && !string.IsNullOrEmpty(eventArgs.Data))
                    {
                        Build.Log.Verbose(eventArgs.Data);
                    }
                };

                process.ErrorDataReceived += (sender, eventArgs) => {
                    error += eventArgs.Data + Environment.NewLine;

                    if (!quiet && !string.IsNullOrEmpty(eventArgs.Data))
                    {
                        Build.Log.Error(eventArgs.Data);
                    }
                };

                // start the process
                process.Start();

                if (redirect)
                {
                    // begin reading output and error streams
                    process.BeginOutputReadLine();
                    process.BeginErrorReadLine();
                }

                if (wait || process.HasExited)
                {
                    // wait for the process to exit
                    process.WaitForExit();

                    // determine if the exit code is an error
                    if (process.ExitCode == 0)
                    {
                        // set the result to the standard out
                        result = standard.TrimEnd(Environment.NewLine.ToCharArray());

                        // move on immediately
                        return 0;
                    }

                    // set the result to the standard error
                    result = error.TrimEnd(Environment.NewLine.ToCharArray());

                    // set the exit code
                    exitCode = process.ExitCode;

                    // try again
                    continue;
                }

                // track the process
                Processes.Add(process);

                // return zero, since we can't do anything else
                return 0;
            }

            // return the exit code from the process
            return exitCode;
        }

        public static void Wait()
        {
            Console.WriteLine();
            Console.WriteLine("Press <Ctrl> + C to cancel.");

            Console.TreatControlCAsInput = false;
            Console.CancelKeyPress += (sender, args) =>
                {
                    foreach (var process in Processes)
                    {
                        try
                        {
                            process.Kill();
                            process.Close();
                            Build.Log.Verbose(string.Format("Process {0} has exited with code {1}.", process.StartInfo.FileName, process.ExitCode));
                        }
                        catch
                        {
                        }
                    }
                };

            foreach (var process in Processes)
            {
                if (!process.HasExited)
                {
                    Build.Log.Verbose(string.Format("Waiting for process {0} to exit.", process.StartInfo.FileName));
                    process.WaitForExit();
                }

                try
                {
                    Build.Log.Verbose(string.Format("Process {0} has exited with code {1}.", process.StartInfo.FileName, process.ExitCode));
                    process.Close();
                }
                catch
                {
                }
            }
        }

        public static IEnumerable<string> GetPathsContaining(string path, string filter, params string[] excludes)
        {
            if (string.IsNullOrEmpty(path))
            {
                path = Directory.GetCurrentDirectory();
            }

            if (!Directory.Exists(path))
            {
                return new List<string>();
            }

            excludes = DefaultExcludes.Union(excludes).ToArray();

            var files = Directory.GetFiles(path, filter, SearchOption.AllDirectories).AsEnumerable();

            var separator = Path.DirectorySeparatorChar;

            foreach (var exclude in excludes)
            {
                files = files.Where(f => f.IndexOf(separator + exclude.Trim(separator) + separator) < 0);
            }

            return files.Select(f => Path.GetDirectoryName(f)).Distinct();
        }

        public static IEnumerable<string> GetPaths(string path, string filter)
        {
            if (string.IsNullOrEmpty(path))
            {
                path = Directory.GetCurrentDirectory();
            }

            if (!Directory.Exists(path))
            {
                return new List<string>();
            }

            return Directory
                .EnumerateFiles(path, filter, SearchOption.AllDirectories)
                .Distinct();
        }

        /// <summary>
        /// Creates the directory (recursively) at the specified <paramref name="path"/>.
        /// </summary>
        /// <param name="path">
        /// The fully-qualified path of the directory to create.
        /// </param>
        public static string MakeDirectory(string path)
        {
            return Directory.Exists(path) ? path : Directory.CreateDirectory(path).FullName;
        }

        public static void RemoveDirectory(string path)
        {
            if (!Directory.Exists(path))
            {
                return;
            }

            try
            {
                var dir = new DirectoryInfo(path);
                dir.Attributes &= ~FileAttributes.ReadOnly;

                foreach (var info in dir.GetFileSystemInfos("*", SearchOption.AllDirectories))
                {
                    info.Attributes &= ~FileAttributes.ReadOnly;
                }

                dir.Delete(true);
            }
            catch (Exception netEx)
            {
                Build.Log.Warn("remove directory: " + netEx.Message);
            }
        }

        public static bool TryGetRepositoryRoot(ref string root)
        {
            try
            {
                if (!Directory.Exists(root))
                {
                    return false;
                }

                var current = new DirectoryInfo(root);

                string path;

                do
                {
                    path = Path.Combine(current.FullName, ".git");

                    if (Directory.Exists(path))
                    {
                        root = current.FullName;

                        return true;
                    }
                }   while((current = current.Parent) != null);
            }
            catch (Exception netEx)
            {
                Log.Verbose(netEx.Message);

                return false;
            }

            return false;
        }

        /// <summary>
        /// Gets or sets the log used to emmit log entries.
        /// </summary>
        public static IQuietLog Log { get; set; }
    }
}